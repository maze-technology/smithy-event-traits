name: Build & Security Scan

on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
  # INFO: Daily security scan
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch: {}

permissions:
  contents: read
  actions: read
  checks: write
  issues: write
  packages: read

env:
  JAVA_HOME: "" # INFO: Force JAVA_HOME to be empty, so gradle will use the sdkman java version
  GITHUB_TOKEN: ${{ github.token }}
  GITHUB_USERNAME: x-access-token

jobs:
  build_scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      checks: write
      issues: write
      packages: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v6

      - name: Cache SDKMAN
        uses: actions/cache@v4
        with:
          path: ~/.sdkman
          key: sdkman-${{ runner.os }}-${{ hashFiles('.sdkmanrc') }}

      - name: Install SDKMAN
        uses: sdkman/sdkman-action@b1f9b696c79148b66d3d3a06f7ea801820318d0f

      # INFO: Tell Gradle which JDK to use *regardless* of what happens to JAVA_HOME
      - name: Point Gradle at the SDKMAN JDK
        run: echo "JAVA_HOME=$HOME/.sdkman/candidates/java/current" >> $GITHUB_ENV

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v5

      - name: Build with Gradle
        run: ./gradlew build

      - name: Extract Maven coordinates
        id: maven_coords
        if: github.event_name == 'pull_request'
        run: |
          # Get coordinates from Gradle task
          COORDS=$(./gradlew -q printCoordinates)

          GROUP_ID=$(echo "$COORDS" | grep '^group=' | cut -d= -f2)
          ARTIFACT_ID=$(echo "$COORDS" | grep '^artifactId=' | cut -d= -f2)

          if [ -z "$GROUP_ID" ] || [ -z "$ARTIFACT_ID" ]; then
            echo "Could not extract Maven coordinates from Gradle"
            echo "Output was: $COORDS"
            exit 1
          fi

          # Convert group dots to slashes for Maven path (e.g., "tech.maze" -> "tech/maze")
          GROUP_PATH=$(echo "$GROUP_ID" | tr '.' '/')

          echo "group=$GROUP_ID" >> $GITHUB_OUTPUT
          echo "artifact=$ARTIFACT_ID" >> $GITHUB_OUTPUT
          echo "group_path=$GROUP_PATH" >> $GITHUB_OUTPUT
          echo "Extracted: group=$GROUP_ID, artifact=$ARTIFACT_ID, group_path=$GROUP_PATH"

      - name: Get latest published version
        id: get_latest_version
        if: github.event_name == 'pull_request'
        run: |
          # Get the latest release tag (gracefully handle missing releases)
          LATEST_TAG=$(gh release view --json tagName --jq '.tagName' 2>/dev/null || true)
          if [ -z "$LATEST_TAG" ]; then
            echo "No published version found, skipping baseline comparison"
            echo "has_baseline=false" >> $GITHUB_OUTPUT
          else
            echo "latest_version=$LATEST_TAG" >> $GITHUB_OUTPUT
            echo "has_baseline=true" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download latest published JAR
        if: github.event_name == 'pull_request' && steps.get_latest_version.outputs.has_baseline == 'true'
        run: |
          VERSION="${{ steps.get_latest_version.outputs.latest_version }}"
          GROUP_PATH="${{ steps.maven_coords.outputs.group_path }}"
          ARTIFACT="${{ steps.maven_coords.outputs.artifact }}"
          mkdir -p baseline-jar
          # Download from GitHub Packages Maven repository
          JAR_URL="https://maven.pkg.github.com/${{ github.repository }}/${GROUP_PATH}/${ARTIFACT}/${VERSION}/${ARTIFACT}-${VERSION}.jar"
          echo "Downloading JAR from: $JAR_URL"
          # If baseline exists, download is required for vulnerability comparison
          curl -L -f -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -o baseline-jar/${ARTIFACT}-${VERSION}.jar \
            "$JAR_URL"

      - name: Scan current build with Trivy (for PRs)
        if: github.event_name == 'pull_request'
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: "fs"
          scan-ref: "${{ github.workspace }}/build/libs"
          format: "table"
          exit-code: "0"
          severity: "HIGH,CRITICAL"

      - name: Scan current build with Trivy (for manual/scheduled triggers)
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: "fs"
          scan-ref: "${{ github.workspace }}/build/libs"
          format: "table"
          severity: "HIGH,CRITICAL"
          exit-code: "1"

      - name: Scan baseline JAR with Trivy
        id: scan_baseline
        if: github.event_name == 'pull_request' && steps.get_latest_version.outputs.has_baseline == 'true'
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: "fs"
          scan-ref: "${{ github.workspace }}/baseline-jar"
          format: "json"
          output: "baseline-trivy-results.json"
          severity: "HIGH,CRITICAL"
          exit-code: "0"
          skip-setup-trivy: true

      - name: Scan current build with Trivy (JSON for comparison)
        id: scan_current
        if: github.event_name == 'pull_request'
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: "fs"
          scan-ref: "${{ github.workspace }}/build/libs"
          format: "json"
          output: "current-trivy-results.json"
          exit-code: "0"
          severity: "HIGH,CRITICAL"
          skip-setup-trivy: true

      - name: Compare vulnerabilities and fail on new ones
        if: github.event_name == 'pull_request' && steps.get_latest_version.outputs.has_baseline == 'true'
        run: |
          python3 << 'EOF'
          import json
          import sys
          import os

          def extract_vulns(json_file):
              """Extract unique vulnerability IDs from trivy JSON output"""
              try:
                  with open(json_file, 'r') as f:
                      data = json.load(f)
                  vulns = set()
                  for result in data.get('Results', []):
                      for vuln in result.get('Vulnerabilities', []):
                          vuln_id = vuln.get('VulnerabilityID', '')
                          if vuln_id:
                              vulns.add(vuln_id)
                  return vulns
              except (FileNotFoundError, json.JSONDecodeError, KeyError):
                  return set()

          baseline_file = 'baseline-trivy-results.json'
          current_file = 'current-trivy-results.json'

          # Validate baseline file exists and is not empty
          if not os.path.exists(baseline_file) or os.path.getsize(baseline_file) == 0:
              print("⚠️  Baseline scan results are missing or empty. Skipping comparison.")
              print("   This may happen if the baseline JAR download failed or the scan failed.")
              print("   Current build vulnerabilities will be shown but comparison is skipped.")
              sys.exit(0)

          # Validate current scan file exists and is not empty
          if not os.path.exists(current_file) or os.path.getsize(current_file) == 0:
              print("❌ Current scan results are missing or empty. Cannot perform comparison.")
              print("   This indicates the current build scan failed or was skipped.")
              print("   Please check the scan step logs for errors.")
              sys.exit(1)

          # Validate current scan file is valid JSON
          try:
              with open(current_file, 'r') as f:
                  json.load(f)  # Just validate it's valid JSON
          except json.JSONDecodeError as e:
              print(f"❌ Current scan results are invalid JSON. Cannot perform comparison.")
              print(f"   JSON decode error: {e}")
              sys.exit(1)
          except Exception as e:
              print(f"❌ Unexpected error reading current scan results: {e}")
              sys.exit(1)

          baseline_vulns = extract_vulns(baseline_file)
          current_vulns = extract_vulns(current_file)

          # Baseline file exists and is valid JSON; empty baseline is valid.
          if not baseline_vulns:
              print("ℹ️  Baseline scan found no vulnerabilities (empty baseline).")

          new_vulns = current_vulns - baseline_vulns
          fixed_vulns = baseline_vulns - current_vulns

          print(f"Baseline vulnerabilities: {len(baseline_vulns)}")
          print(f"Current vulnerabilities: {len(current_vulns)}")
          print(f"New vulnerabilities: {len(new_vulns)}")
          print(f"Fixed vulnerabilities: {len(fixed_vulns)}")

          # Write counts to files for PR comment evaluation
          with open('new-vulns-count.txt', 'w') as f:
              f.write(str(len(new_vulns)))
          with open('current-vulns-count.txt', 'w') as f:
              f.write(str(len(current_vulns)))

          if new_vulns:
              print("\n❌ NEW VULNERABILITIES DETECTED:")
              for vuln in sorted(new_vulns):
                  print(f"  - {vuln}")
              sys.exit(1)
          elif fixed_vulns:
              print("\n✅ Some vulnerabilities were fixed:")
              for vuln in sorted(fixed_vulns):
                  print(f"  - {vuln}")
          else:
              print("\n✅ No new vulnerabilities detected")
          EOF

      - name: Evaluate vulnerability status for PR comment
        if: github.event_name == 'pull_request'
        id: vuln_eval
        run: |
          # Check if comparison actually ran and completed successfully
          if [ -f new-vulns-count.txt ] && [ -f current-vulns-count.txt ]; then
            NEW_COUNT=$(cat new-vulns-count.txt)
            PR_COUNT=$(cat current-vulns-count.txt)
            COMPARISON_RAN=true
          else
            # No comparison occurred - don't set counts for comment
            NEW_COUNT=0
            PR_COUNT=0
            COMPARISON_RAN=false
          fi
          echo "new_count=${NEW_COUNT}" >> $GITHUB_OUTPUT
          echo "pr_count=${PR_COUNT}" >> $GITHUB_OUTPUT
          echo "comparison_ran=${COMPARISON_RAN}" >> $GITHUB_OUTPUT

      - name: Comment on PR about existing vulnerabilities
        if: github.event_name == 'pull_request' && steps.vuln_eval.outputs.comparison_ran == 'true'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: security-scan
          recreate: true
          message: |
            ### Security scan
            - No new HIGH/CRITICAL vulnerabilities introduced.
            - ${{ steps.vuln_eval.outputs.pr_count }} existing HIGH/CRITICAL vulnerabilities remain in the PR artifacts.

            Check the workflow run's Summary for details.
